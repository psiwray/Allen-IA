from getopt import getopt
from os import linesep
from pathlib import Path
from subprocess import run
from sys import argv
from typing import Optional

from allen.clause import clause_to_string
from allen.input.inverse_relationships_table import read_inverse_relationships_table
from allen.input.ternary_constraints_table import read_ternary_constraints_table
from allen.input.time_intervals_table import read_time_intervals_table
from allen.output.sat_output import generate_sat_output_for_group, Data, Coding

if __name__ == "__main__":
    matched_args, remaining_args = getopt(argv[1:], "d:c:o:s", ["data=", "coding=", "output=", "solver="])


    def find_argument(short: str, long: str) -> Optional[str]:
        for arg_name, arg_value in matched_args:
            if arg_name == short or arg_name == long:
                return arg_value

        return None


    # Parse the arguments from the command-line input.
    data_folder = find_argument("-d", "--data") or "."
    coding = find_argument("-c", "--coding") or "ternary_impl"
    output_folder = find_argument("-o", "--output") or "."
    solver_path = find_argument("-s", "--solver") or "minisat"
    input_file = remaining_args[0]

    # Read the data from the
    data = Data(
        read_inverse_relationships_table(f"{data_folder}/inverse_relationships_table.txt"),
        read_ternary_constraints_table(f"{data_folder}/ternary_constraints_table.txt")
    )

    # Choose the preferred coding, if specified else choose a default one.
    coding_enum = ""
    if coding == "ternary_impl":
        coding_enum = Coding.TERNARY_IMPLICATION
    elif coding == "expression_ref":
        coding_enum = Coding.EXPRESSION_REFERENCE

    # Write the result to files, one for every group.
    try:
        Path(output_folder).mkdir(parents=True, exist_ok=True)
    except FileExistsError:
        pass

    for group in read_time_intervals_table(input_file):
        print(f"Working for group number {group.number}.")

        generation_result = generate_sat_output_for_group(group, data, coding_enum)
        total_literals = generation_result.number_dict.get_current_number() - 1

        Path(output_folder, str(group.number)).mkdir(parents=False, exist_ok=True)

        with open(f"{output_folder}/{group.number}/sat_input.txt", "w") as file:
            file.write(f"c{group.comment}{linesep}")
            file.write(f"p cnf {total_literals} {len(generation_result.number_lines)}{linesep}")
            for output in generation_result.number_lines:
                file.write(output)
                file.write(linesep)

        # Also write the corresponding mathematical representation to a separate file, with the same name but
        # having a different extension.
        with open(f"{output_folder}/{group.number}/sat_input_math.txt", "w") as file:
            for output in generation_result.math_lines:
                file.write(output)
                file.write(linesep)

        # Now that everything has been written to file, the SAT solver should be called on the current input.
        solver_result = run([solver_path, "sat_input.txt", "sat_output.txt"], cwd=f"{output_folder}/{group.number}",
                            capture_output=True)

        if solver_result.returncode == 10:
            print("The SAT solver found a series of boolean values for the variables that satisfy the expression.")
        elif solver_result.returncode == 20:
            print("The SAT solver wasn't able to satisfy the boolean expression.")
        elif solver_result.returncode == 0:
            print("The SAT solver had trouble starting.")
        elif solver_result.returncode == 1:
            print("The SAT solver was interrupted.")
        elif solver_result.returncode == 3:
            print("The SAT solver had trouble parsing the input.")

        with open(f"{output_folder}/{group.number}/solver_log.txt", "w") as file:
            file.write(solver_result.stdout.decode("utf-8"))
        with open(f"{output_folder}/{group.number}/solver_error.txt", "w") as file:
            file.write(solver_result.stderr.decode("utf-8"))

        if solver_result.returncode == 10:
            # Now for every variable that has been generated by the SAT solver as satisfying the boolean expression,
            # find the mathematical representation of it from the generated clauses.
            with open(f"{output_folder}/{group.number}/variable_mapping.txt", "w") as variable_mapping:
                with open(f"{output_folder}/{group.number}/sat_output.txt", "r") as sat_result:
                    for variable_id in sat_result.readlines()[1].split(" "):
                        variable_number = int(variable_id)
                        variable_true = False
                        if variable_number == 0:
                            break
                        elif variable_number < 0:
                            variable_true = False
                        elif variable_number > 0:
                            variable_true = True

                        variables = generation_result.number_dict
                        literal = variables.get_literal_from_number(abs(variable_number))
                        if literal is None:
                            literal = variables.get_expression_literal_from_number(abs(variable_number))
                            if literal is None:
                                raise RuntimeError(f"Found a missing literal: {variable_number}.")

                        if variable_true:
                            negated = literal.negated
                            literal.negated = False
                            variable_mapping.write(f"{variable_number} {clause_to_string([literal])}")
                            variable_mapping.write(linesep)
                            literal.negated = True  # Restore the previous value for posterity.

        pass
